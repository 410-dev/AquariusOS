#!/bin/bash

# ==============================================================================
# Btrfs Snapshot Prober & GRUB Reconstructor
# ==============================================================================
# Usage:
#   snapshot-prober                  (List snapshots found on disk)
#   snapshot-prober --reconstruct-grub  (Regenerate /etc/grub.d/42... and update-grub)
# ==============================================================================

set -e

# --- Configuration ---
GRUB_SNAP_FILE="/etc/grub.d/42_btrfs_snapshots"
MOUNT_POINT="/mnt/btrfs_prober_root"
IS_SANDBOX=false

# --- Helper: Detect Environment ---
detect_boot_environment() {
    if findmnt / -n -o FSTYPE | grep -q "overlay"; then
        IS_SANDBOX=true
        RAW_SOURCE=$(findmnt /media/root-ro -n -o SOURCE)
        CURRENT_SUBVOL=$(echo "$RAW_SOURCE" | sed 's/.*\[\/\(.*\)\]/\1/')
    else
        RAW_SOURCE=$(findmnt / -n -o SOURCE)
        CURRENT_SUBVOL=$(echo "$RAW_SOURCE" | sed 's/.*\[\/\(.*\)\]/\1/')
    fi
}

# --- Helper: Mount Root ---
mount_root() {
    local ROOT_DEVICE=""
    if [[ "$IS_SANDBOX" == "true" ]]; then
        ROOT_DEVICE=$(findmnt /media/root-ro -n -o SOURCE | sed 's/\[.*//')
    else
        ROOT_DEVICE=$(findmnt / -n -o SOURCE | sed 's/\[.*//')
    fi

    if [[ -z "$ROOT_DEVICE" ]]; then echo "Error: Cannot find root device."; exit 1; fi

    mkdir -p "$MOUNT_POINT"
    mount -o subvolid=5 "$ROOT_DEVICE" "$MOUNT_POINT"
}

# --- Command: List ---
list_snapshots() {
    echo "Scanning Btrfs Root for snapshots..."
    echo "---------------------------------------------------------------------------------"
    printf "%-35s | %-15s | %s\n" "Snapshot Name" "Kernel Version" "UUID"
    echo "---------------------------------------------------------------------------------"

    # Find directories starting with @snapshot
    for snap_path in "$MOUNT_POINT"/@snapshot*; do
        if [[ -d "$snap_path" ]]; then
            SNAP_NAME=$(basename "$snap_path")

            # Detect Kernel inside snapshot /boot
            # We look for the symlink 'vmlinuz' or the file 'vmlinuz-*'
            if [[ -L "$snap_path/boot/vmlinuz" ]]; then
                KERNEL_VER=$(readlink "$snap_path/boot/vmlinuz" | sed 's/vmlinuz-//')
            elif ls "$snap_path"/boot/vmlinuz-* 1> /dev/null 2>&1; then
                KERNEL_VER=$(ls "$snap_path"/boot/vmlinuz-* | head -n 1 | sed 's/.*vmlinuz-//')
            else
                KERNEL_VER="Unknown"
            fi

            printf "%-35s | %-15s | ...\n" "$SNAP_NAME" "$KERNEL_VER"
        fi
    done
    echo "---------------------------------------------------------------------------------"
}

list_simple() {
    for snap_path in "$MOUNT_POINT"/@snapshot*; do
        if [[ -d "$snap_path" ]]; then
            SNAP_NAME=$(basename "$snap_path")
            echo "$SNAP_NAME"
        fi
    done
}

# --- Command: Reconstruct ---
reconstruct_grub() {
    local SKIP_UPDATE=$1

    echo "[-] Initializing $GRUB_SNAP_FILE..."

    ROOT_DEVICE=$(findmnt "$MOUNT_POINT" -n -o SOURCE | sed 's/\[.*//')
    FS_UUID=$(blkid -s UUID -o value "$ROOT_DEVICE")

    # Base arguments (strip everything specific)
    BASE_ARGS=$(cat /proc/cmdline | sed 's/root=UUID=[^ ]*//g' | sed 's/rootflags=[^ ]*//g' | sed 's/overlayroot=[^ ]*//g' | sed 's/ ro / /g' | sed 's/ rw / /g')

    cat <<EOF > "$GRUB_SNAP_FILE"
#!/bin/sh
exec tail -n +3 \$0
# Auto-generated by snapshot-prober
EOF
    chmod +x "$GRUB_SNAP_FILE"

    echo "[-] Scanning and generating entries..."

    COUNT=0
    for snap_path in "$MOUNT_POINT"/@snapshot*; do
        if [[ -d "$snap_path" ]]; then
            SNAP_NAME=$(basename "$snap_path")
            PRETTY_NAME="${SNAP_NAME#@snapshot-}"

            # 1. Detect Kernel (Same as before)
            if [[ -f "$snap_path/boot/vmlinuz" && -f "$snap_path/boot/initrd.img" ]]; then
                K_PATH="/$SNAP_NAME/boot/vmlinuz"
                I_PATH="/$SNAP_NAME/boot/initrd.img"
            elif ls "$snap_path"/boot/vmlinuz-* 1> /dev/null 2>&1; then
                K_FILE=$(ls "$snap_path"/boot/vmlinuz-* | head -n 1)
                I_FILE=$(ls "$snap_path"/boot/initrd.img-* | head -n 1)
                K_PATH="/$SNAP_NAME/boot/$(basename "$K_FILE")"
                I_PATH="/$SNAP_NAME/boot/$(basename "$I_FILE")"
            else
                continue
            fi

            # 2. Detect Snapshot Mode (The Fix)
            META_FILE="$snap_path/etc/btrfs-snap.info"
            SNAP_TYPE="bootable" # Default

            if [[ -f "$META_FILE" ]]; then
                # Read content, look for TYPE=...
                SNAP_TYPE=$(grep "TYPE=" "$META_FILE" | cut -d= -f2 | tr -d '[:space:]')
            fi

            # 3. Configure Arguments based on Mode
            if [[ "$SNAP_TYPE" == "sandbox" ]]; then
                echo "    [+] Found SANDBOX snapshot: $SNAP_NAME"
                FINAL_ARGS="$BASE_ARGS overlayroot=tmpfs"
                RW_RO="ro"
                TITLE="Sandbox: $PRETTY_NAME (RAM)"
            else
                echo "    [+] Found BOOTABLE snapshot: $SNAP_NAME"
                FINAL_ARGS="$BASE_ARGS"
                RW_RO="rw"
                TITLE="Snapshot: $PRETTY_NAME"
            fi

            # 4. Write Entry
            cat <<EOF >> "$GRUB_SNAP_FILE"
menuentry '$TITLE' --class ubuntu --class gnu-linux --class gnu --class os {
    recordfail
    load_video
    gfxmode \$linux_gfx_mode
    insmod gzio
    insmod part_gpt
    insmod btrfs
    search --no-floppy --fs-uuid --set=root $FS_UUID
    echo 'Loading Kernel...'
    linux $K_PATH root=UUID=$FS_UUID rootflags=subvol=$SNAP_NAME $RW_RO $FINAL_ARGS
    echo 'Loading Initrd...'
    initrd $I_PATH
}
EOF
            COUNT=$((COUNT+1))
        fi
    done

    echo "[-] Found $COUNT snapshots."

    if [[ "$SKIP_UPDATE" == "--no-update" ]]; then
        echo "[-] Skipping update-grub (Requested via --no-update)."
    else
        echo "[-] Running update-grub..."
        update-grub
    fi
}

# --- Main Execution ---

if [[ $EUID -ne 0 ]]; then echo "Run as root."; exit 1; fi

detect_boot_environment
mount_root

case $1 in
    --reconstruct-grub)
        reconstruct_grub "$2"
        ;;
    --list-simple)
        list_simple
        ;;
    *)
        list_snapshots
        ;;
esac

umount "$MOUNT_POINT"
rmdir "$MOUNT_POINT"
